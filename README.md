# JS-and-React
## Create React App (CRA)
Создает приложения React без конфигурации сборки.

https://github.com/facebook/create-react-app

Добавление библиотеки в проект:
```
npx create-react-app <название проекта>
```

Структура проекта после добавления библиотеки:
1. public: содержит статичные файлы
    - index.html - основополагающий файл, где в элемент \<div id="root"\> включается код.
2. src:
    - index.js - самый главный файл, входная точка
    - App.js - содержит всю базовую разметку, само приложение
    - reportWebVitals.js

Документация React: https://ru.legacy.reactjs.org/

## Препроцессор JSX
Функция рендеринга страницы должна запускаться один раз:
```
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
  <App />
  </React.StrictMode>
);
```

### Создание элемента:
1. `const elem = <h2>Hello World!</h2>;`
2. `const elem = React.createElement('h2', {className: 'greetings'}, 'Hello World!');` - второй аргумент - классы элемента

Метод `createElement` создает следующий объект
```
const element = {
    type: 'h2',
    props: {
        className: 'greetings',
        children: 'Hello World!'
    }
};
```

> Если элемент имеет вложенную многострочную структуру, то нужно оборачивать ее в круглые скобки. У такого элемента всегда должен быть один корневой элемент!
```
const elem = (
  <div>
    <h2>Hello World!</h2>
    <input type="text"/>
    <button/>
  </div>
);
```

### Подстановка переменных в элемент
```
const text = 'World!';
const elem = (
  <div>
    <h2>Hello {text}</h2>
    <input type="text"/>
    <button/>
  </div>
);
```

Можно подставлять функции, методы, свойства объектов и т.д.
> Исключение - не подставляются объекты. Частный случай объекта, массив, подставится, но все элементы массива схлопнутся в одну строку.

### Атрибуты элементов
Можно добавлять атрибуты к элементам, но нужно писать их в camelCase (например, tabIndex):
```
const elem = (
  <div>
    <h2>Hello World! {text}</h2>
    <input type="text"/>
    <button tabIndex="0">CLick Me</button>
  </div>
);
```
Добавить класс можно через атрибут className:
```
<h2 className="text">Hello World! {text}</h2>
```
На странице он преобразуется в `class`.

## React компоненты
Одна из основных концепций React-a - разбиение приложения на компоненты.

Компоненты - блоки пользовательского интерфейса, которые могут иметь собственное поведение и повторно использоваться.

Элементы - неизменяемые. Когда он отрендерился на странице, его нельзя просто так изменить. Если мы хотим изменить элемент, нужно полностью перерисовать его на странице.

### Правила компонентов
1. Компоненты всегда пишутся с большой буквы

Создание и использование компонента Header:
```
const Header = () => {
  return <h2>Hello World!</h2>;
};

function App() {
  return (
    <div className="App">
      <Header />
    </div>
  );
}
```
Создание через класс:
```
class Field extends React.Component {
    renderer() { // обязательный метод
        ...
        return <input type="text">
    }
}
```

### Свойства компонентов - props
Props - объект, который передается в React-компонент.
```
function WhoAmI(props) {
  return (
    <div>
      <h1>My name is {props.name}, surname - {props.surname}</h1>
    </div>
  )
}
```
Передача параметров происходит следующим образом:
```
<WhoAmI name="John" surname="Smith"/>
```
### Алгоритм согласования
https://ru.legacy.reactjs.org/docs/reconciliation.html

При работе с React вы понимаете render() как функцию, которая создаёт дерево React-элементов в какой-то момент времени. При следующем обновлении состояния или пропсов функция render() возвращает новое дерево React-элементов.

Алгоритм сравнения:

1. React сравнивает деревья начиная с их корневых элементов и направляется вниз. Сравниваются типы (теги) корневых элементов. Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.
2. При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
3. Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу
4. По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и создаёт мутацию, когда находит отличие. То есть, если добавится новый элемент в начало списка ul, перерисуются все элементы спика. С добавлением в конец все в порядке.

> Для решения проблемы со списками поддерживается атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Ключ должен быть уникальным только среди его соседей, а не глобально. 

### Состояния компонентов
https://ru.legacy.reactjs.org/docs/state-and-lifecycle.html

«Состояние» очень похоже на пропсы, отличие в том, что состояние контролируется и доступно только конкретному компоненту.

Состояние может добавляться через хуки или в классовый компонент (не функциональный):
```
class WhoAmI extends React.Component {
  constructor(props) {
    super(props);
    this.state = { // объект состояния
      years: 27
    }
  }

  nextYear = () => {
    this.setState({ // для изменения состояния необходимо использовать метод setState
      years: this.state.years + 1 // менять состояние напрямую нельзя
    })
  }

  render() {
    const {name, surname, link} = this.props;
    return (
      <div>
        <button onClick={this.nextYear}>+++</button> // можно вызвать метод внутри верстки
        <h1>My name is {name}, age - {this.state.years}</h1>
      </div>
    )
  }
}

```

1. У коммпонента можно может быть свое внутреннее состояние, которое динамически меняется
2. Состояние мб как у классовых, так и у функциональных компонентов
3. State напрямую менять нельзя, только через команду setState
4. setState - это асинхронная операция, если нужна точность и последовательность операций, необходимо передавать коллбэк.
5. В команде setState можно изменять только те свойства, которые нужны. Остальные останутся без изменений.

## События в React-е
Чтобы назначить обработчик события, нужно прописать событие в формате camelCase:
```
<button onClick={this.nextYear}>Click</button>
```
Здесь названия методов аналогичны: onChange, onSubmit, onHover и т.д.

Обработка событий:
1. Если функция записана не в стрелочном виде
```
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // Эта привязка обязательна для работы `this` в колбэке.
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }
}
```
2. Запись функции как поля
```
 handleClick = () => {
    console.log('значение this:', this);
  };
```
3. Анонимная функция при вызове
```
handleClick() {
    console.log('значение this:', this);
}

  render() {
    // Такой синтаксис гарантирует, что `this` привязан к handleClick.
    return (
      <button onClick={() => this.handleClick()}>
        Нажми на меня
      </button>
    );
  }
```