# JS-and-React
## Псевдомассивы
https://habr.com/ru/articles/336136/

Псевдомассив — это объект, который структурно похож на массив. То есть у него есть числовые свойства (индексы) и свойство length.

Пример:
```
{0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 3};
```

Когда мы посмотрим в свойства массива, то увидим, что он наследует прототип Array объекта. То есть, все свойства, которые есть в объекте Array.prototype будут доступны для любого массива. Если же посмотреть в свойства какого-либо псевдомассива, то можно заметить, что он наследует прототип другого объекта вместе с другими свойствами.

## Действия с элементами на странице
Свойство `style` в объекте - это работа с inline стилями. Работа со стилями css происходит иначе.

Пример изменения стиля элемента из кода (вставляет inline стиль):
```
element.style.backgroundColor = 'blue';
```
Иной способ вставить inline стили:
```
element.style.cssText = 'background-color: blue; width: 500px';
```
Полезно при использовании переменных в стилях.

### Создание элементов из кода
Создает элемент только внутри JS, в документе не отобразится.
```
const div = document.createElement('div');
const text = document.createTextNode('Here');
```
Добавить его можно следующим образом:
```
const div = document.createElement('div');
document.body.append(div); // добавление элемента в конец документа
```
1. Prepend - добавляет элементы в начало контейнера.
2. element.before(wantedElement) - добавляет элемент wantedElement перед element
3. after() - аналогично before
4. remove() - удаляет первый элемент внутри.
5. replacedElement.replaceWith(wantedElement) - заменяет replacedElement на wantedElement.
6. appendChild()
7. element.remove() - удаляется element

### Добавление стилей или текста
В элемент, созданный в JS, можно добавить стиль:
```
div.classList.add('black');
```
 Добавить текст можно 3 способами:
 1. div.`innerHTML` = "\<h1\>Hello World\</h1\>" - можно добавить текст вместе с HTML тегами
 2. div.`textContent` = "Hello World" - работает только с текстом, теги не обрабатываются и остаются в виде строки.
 3. div.`insertAdjacentHTML`('beforebegin', '\<h2\>Hello\</h2\>') - помещает строку в элемент div. 'beforebegin' - вставляется перед элементом; 'afterbegin' - вставляет первым элементом внутри элемента; 'beforeend' - последним элементом внутри; 'afterend' - после элемента.

## Взаимодействия с элементами на странице - события и их обработчики

Справочник по событиям - https://developer.mozilla.org/ru/docs/Web/Events.

Обработчик - функция, которая срабатывает, как только событие произошло.

Способы назначения обработчика:
1. `<button onclick="alert('Click')">` - вставка прямо в HTML
2. `btn.onclick = () => alert('Click');` - из JS такая же обработка клика.
3. `btn.addEventListener('click', () => {alert('Click');})` - здесь alert - это коллбэк функция, которая выполняется после выполнения 'click'. Здесь можно записывать не только click, но и любое другое действие.

Если требуется получить информацию о событии, в коллбэк функцию нужно передать объект event, имеющий собственные свойства. Свои переменные в функцию нужно передавать строго после объекта event:
```
btn.addEventListener('click', (e, <your fields>) => {
    console.log(e);
})
```

https://developer.mozilla.org/ru/docs/Web/API/Event

Элемент, вызвавший событие, можно получить по свойству target:
```
button.addEventListener('mouseenter', (e) => {
    console.log(e.target); // - button
});
```

Удаление обработчика событий (обработчик вынести в отдельную переменную!):
```
btn.removeEventListener('click', deleteElement);
```

> Если несколько событий происходит на одном элементе и во вложенных в этом элементе, сначала обрабатывается самый вложенный элемент и далее по дереву вверх.

Можно отменять стандартные функции браузера. Пример: переход по ссылке не происходит.
```
link.addEventListener('click', (e) => {
    e.preventDefault();
});
```

Можно добавить опции к слушателю события. Пример - once обработает событие только один раз, далее не будет работать:
```
link.addEventListener('click', deleteElement, {once: true});
```

Доступные опции:
1. capture - указывает, что события этого типа будут отправлены зарегистрированному обработчику listener перед отправкой на EventTarget, расположенный ниже в дереве DOM.
2. once - указывает, что обработчик должен быть вызван не более одного раза после добавления. Если true, обработчик автоматически удаляется при вызове.
3. passive - указывает, что обработчик никогда не вызовет preventDefault(). Если всё же вызов будет произведён, браузер должен игнорировать его и генерировать консольное предупреждение.

## Навигация по DOM - элементам
Обращение к body:
```
document.body
```

Обращение к head:
```
document.head
```

Обращение ко всему содержимому по тегу \<html\>:
```
document.documentElement
```
Получение всех узлов внутри (узлы - не только элементы, но и переносы строк, текст и т.п.):
```
document.body.childNodes
```

Получение первого/последнего узла:
```
document.body.firstChild/lastChild
```

Получение родительского узла:
```
element.parentNode;
```

Получение следующего/предыдущего узла того же уровня:
```
element.nextSibling/previousSibling;
```

> Все предыдущие методы получают именно узлы. Для получения элементов есть аналогичные свойства: parentElement, nextElementSibling, firstElementChild. Функциональности для получения всех элементов нет. 

## Рекурсия
В функции рекурсии должна быть база - шаг, на котором вызов функции останавливается и возвращается конкретное значение. 

Шаг рекурсии - с каждым вызовом функции какой-то из параметров должен уменьшаться, этот параметр явлется шагом рекурсии.

Глубина рекурсии - общее количество вложенных вызовов вместе с первым вызовом. Также есть максимальная глубина рекурсия.

Получить все значения в объекте можно по методу `Object.values()`. Проверить, что объек является массивом можно методом `Array.isArray(object)`.

## События

### Выполнение кода только после готовности документа
Для добавления и выполнения действий после формирования dom документа:
```
document.addEventListener('DOMContentLoaded', () => {весь код над страницей});
```

Для выполнения действий только после полной загрузки документа:
```
```

### Обработка событий на сенсорных устройствах
События имеют название:
1. `touchstart` - нажатие по области
2. `touchmove` - перемещение нажатия
3. `touchend` - окончание нажатия
4. `touchenter` - фокус на елементе
5. `touchleave`
6. `touchcancel`

Можно получить `touches` - количество пальцев (нажатий) на экране, `targetTouches` - список пальцев на элементе, `changedTouches` - список пальцев, участвующих в событии. 

Статья с примерами: https://youon.ru/%D0%90%D0%BD%D0%B4%D1%80%D0%BE%D0%B8%D0%B4/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0/touch-sobytiya-na-javascript-multitach-realizatsiya.

https://habr.com/ru/companies/sibirix/articles/227175/

### Оптимизация загрузки скриптов на странице
1. \<script `defer` src="js/script.js"\>\</script\> - без атрибута скрипт нельзя помещать перед телом страницы, т.к. они еще не готовы. `Defer` позволяет загружать скрипт в фоновом режиме, пока готовится страница, не блокирует загрузку страницу. Ожидает полной загрузки страницы.
2. `async` - асинхронные скрипты не ждут друг друга, но загружаются также в фоновом режиме и работают независимо от загрузки страницы.

### ClassList
Методы работы с классами:
1. add() - можно добавить сколько угодно с классами
2. remove() - удаление класса
3. toggle() - переключает наличие класса. Если он есть, удалит его, иначе добавит
4. contains() - возвращает boolean значение того, есть ли класс в элементе.
5. length - определяет количество классов элемента
6. item(number) - берет класс элемента по порядку number

### Делегирование событий
Можно назначить обработчик события родителю над элементами, которые меняются, чтобы не добавлять каждый раз слушателя события. Определять элемент можно через `event.target.matches()`.

Документация по matches:
https://developer.mozilla.org/ru/docs/Web/API/Element/matches

Статья по делегированию событий: https://learn.javascript.ru/event-delegation

## Операторы нулевого слияния и опциональной цепочки
### Нулевое слияние (Nullish, ??)
Оператор `??` похож на оператор ||, но работает только с 2 значениями: null и undefined.
```
0 || 200 = 200
0 ?? 200 = 0
```
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing
### Опциональная цепочка (?.)
Позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, без необходимости проверять каждое из промежуточных свойств в ней на существование. Можно также проверять наличие метода, например, `element.sayHello?.()`

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining

## Тип данных Symbol
Уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов.
```
let id = Symbol();
obj[id] = 1;
```

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol

### Дескрипторы свойств
1. Object.getOwnPropertyDescriptor(объект, 'свойство')
2. Object.defineProperty(объект, 'свойство', {writable: false}) - изменяет свойства для 'свойства' объекта. Здесь, например, оно становится readonly. Хорошо работает в объектах вместо указания слова `const`.
3. Object.defineProperties(object, 'свойство': {}, 'свойство2': {}) - позволяет менять несколько свойств.

Методы объектов:
1. Object.frezze() - любые изменения над объектом запрещаются.
2. preventExtensions() - предотвращает любое расширение объекта.
3. Object.keys(), .values(), .entries().

## Время выполнения скриптов
1. const timerId = setTimeout(handler, time) - через time миллисекунд срабатывает функция handler.
2. clearInterval(timerId) - отменяет таймаут, действие не выполнится.
3. setInterval - аналогична функции setTimeout, но срабатывает каждые time миллисекунд.

## Сборщик мусора и утечки памяти
### Интерпретация vs Компиляция
Интерпретация - построчное чтение кода и его запуск. Компилятор - сначала вся программа переводится в двоичный код и только потом исполняется.
> JS - интерпретируемый язык.

### Достижимые объекты
https://learn.javascript.ru/garbage-collection

Основной концепцией управления памятью в JavaScript является принцип достижимости. «Достижимые» значения – это те, которые доступны или используются и достижимы из корня. Они гарантированно находятся в памяти.

### Алгоритм сборки
Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).
Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

Движки JavaScript применяют множество оптимизаций, чтобы сборка работала быстрее и не задерживала выполнение кода:

- Сборка по поколениям (Generational collection) – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
- Инкрементальная сборка (Incremental collection) – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
- Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

### Отлавливание утечек памяти
Можно посмотреть в DevTools в разделе performance
https://html-plus.in.ua/kak-izbezhat-utechek-pamyati-v-javascript/

### WeakMap и WeakSet

## Даты
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date

Обработка прошедшей даты